%!TEX root = globs.tex

Our empirical study revealed that globbing's critical deficiencies -- semantic fragmentation across languages, security vulnerabilities, and expressiveness limitations -- are rooted 
in a historical architectural choice. Specifically, the coupling of pattern semantics with system context. We propose a formal specification that codifies the common features 
in existing globbing system, providing a consistent and clear definition of inconsistent behaviors, and provides a clean distinction between logical pattern meaning and system behavior 
for execution. 

\subsection{Separating Pattern Semantics from Execution}

The syntax of the proposed \textbf{GlobSpec} specification is defined using a context-free grammar (CFG) shown below captures the core constructs 
common across existing globbing implementations while introducing new features to address expressiveness gaps. 

\begin{lstlisting}[language=ebnf, caption={GlobSpec Grammar Specification}]
GLOB  ::= COMP "/" GLOB 
          | "**" "/" GLOB 
          | "*" "/" GLOB 
          | COMP 
          | "**"
          | "*"

COMP  ::= TERM COMP 
          | "(" OPTS ")" COMP 
          | "!(" COMP ")" COMP
          | TERM

OPTS  ::= SEQ "|" OPTS 
          | SEQ

SEQ  ::= literal TERM
          | "${" identifier "}" TERM

TERM  ::= literal TERM
          | "${" identifier "}" TERM
          | (@$\epsilon$@)
\end{lstlisting}

\todo{describe the grammar more -- critical common feature support and new substitution, union, and negation constructs}

\textbf{Universal Pattern Semantics (The "What"):} Defined strictly by the context free grammar, this layer specifies the \emph{invariant, mathematical meaning} of patterns independent of any environment. The grammar establishes precise, unambiguous interpretations that remain across all implementations:
\begin{itemize}
\item \texttt{*.txt} means any character sequence followed by the literal sequence of characters ``\texttt{.txt}''
\item \texttt{**/src/*.java} specifies to recursively traverse directory hierarchies to locate directories named ``\texttt{src}'', then match immediate child files ending with ``\texttt{.java}"
\item \texttt{(cat|dog)*} defines the union of files beginning with ``\texttt{cat}'' or ``\texttt{dog}'', followed by any character sequence
\item \texttt{!(*.log|*.tmp)} expresses the set exclusion of files matching either \texttt{*.log} or \texttt{*.tmp} patterns
\end{itemize}

These semantic definitions remain universal across all implementations, analogous to how SQL query semantics maintain consistent meaning across different database engines. The grammar ensures that a pattern's logical intent is preserved regardless of the underlying platform, programming language, or filesystem characteristics, establishing a foundation for predictable and portable file matching operations.

\textbf{Execution Behaviors (The "How"):} This layer manages necessary environmental adaptations through explicit configuration flags, ensure consistent pattern semantics while accommodating platform differences. Each behavior is controlled by well-defined parameters:
\begin{itemize}
\item \textbf{Case Sensitivity}: A \texttt{case\_sensitive} flag determines matching behavior, resolving fundamental inconsistency between Windows and Linux platforms.
\item \textbf{Symlink Following}: A \texttt{follow\_symlinks} flag controls whether symbolic links are traversed during recursive matching, eliminating the behavior differences documented between Python \texttt{pathlib} and \texttt{glob} implementations.
\item \textbf{Path Separator Normalization}: The grammar standardizes on forward slash (\texttt{/}) as the path separator, while implementations transparently convert to platform-native separators, ensuring consistent pattern interpretation across operating systems.
\item \textbf{Unicode Normalization}: Standardized encoding ensures consistent character matching across filesystems.
\end{itemize}

\subsection{Bridging Expressiveness Gaps}
This architectural separation systematically addresses both the fragmentation and expressiveness limitations.

The grammar eliminates semantic fragmentation by fixing core pattern meanings. A recursive wildcard \texttt{**} \emph{always} means recursive directory traversal it cannot be unsupported or require special flags to activate its fundamental semantics. Flags only control execution details like symlink following during recursion. This resolves the platform specific semantic drift responsible for 49.5\% of compatibility issues, where path separator ambiguity (18.7\% of cross platform failures) is eliminated through invariant parsing rules.

The expressiveness limitations documented in RQ4 find comprehensive solutions through GlobSpec's composition mechanisms. The union and substitution rules enable advanced pattern operations previously requiring manual workarounds:
\begin{lstlisting}[language=ebnf, caption={GlobSpec Union, and Substitution Rules}]
<enclosed_union> ::= "(" <union> ")"
<union> ::= <expr> "|" <union> | <expr> "|" <expr>
<substitution> ::= "${" <var_name> "}"
<var_name> ::= [a-zA-Z0-9_]+
\end{lstlisting}
This formalism resolves the \textbf{Negation Paradox} (29.5\% feature requests vs. 0.02\% usage) by enabling principled exclusion patterns like \texttt{!(*.log|*.tmp)} as logical set operations. Unlike current brittle implementation specific features, these become first class language constructs with predictable semantics.

The substitution mechanism \texttt{\$\{}pattern\_name\texttt{\}} addresses 19.7\% of feature gap requests by enabling pattern reuse and composition. This eliminates the manual filtering workarounds that contribute to 23.5\% of performance issues, where developers currently process all files only to discard most during post filtering.

Crucially, GlobSpec's regular language foundation enables linear time pattern checking through finite automata compilation, guaranteeing predictable performance and preventing the exponential complexity that plagues direct matching implementations.

\subsection{Transforming Globbing into a Software Engineering Primitive}
GlobSpec transforms globbing from a world of \textbf{implicit, hidden behaviors} where identical pattern strings produce different results across contexts to a world of \textbf{explicit, controlled execution} where patterns maintain universal meaning through transparent, configurable interfaces.

This architectural shift enables reference implementations, pattern validation tools, cross platform testing suites, and security auditing capabilities previously impossible with implementation defined globbing. By providing this formal foundation, GlobSpec addresses the reliability, security, and portability concerns quantified throughout our empirical study while establishing globbing as a verifiable software engineering primitive.
