%!TEX root = globs.tex

This study employs a mixed-methods approach to comprehensively investigate glob pattern usage across programming ecosystems. Our methodology integrates quantitative analysis of 
$62,713$ glob patterns extracted from $1,966$ open-source repositories with qualitative analysis of $2,160$ developer discussions from Stack Overflow, GitHub issues, and CVE 
databases. This multi-method approach enables us to establish both technical implementation landscapes and practical developer experiences.

\subsection{Language and Environment Selection}

We selected six environments that utilize glob patterns which represent diverse use-cases and implementation paradigms. Our primary selection criteria was covering the diverse set 
of scenarios where globbing has been integrated into the ecosystem as a DSL. This selection is based primarily in the authors $15$ years of experience working with large software 
companies, primarily Microsoft, and experience there with projects on build systems, programming language implementation, and cloud development. Secondarily, we used the TIOBE index 
to ensure we covered a diverse set of popular programming languages~\cite{tiobe}. The selected languages and their glob implementations are as follows: Bash (shell and file-system focused), 
JavaScript/Node.js (URI and server routes + git usage), Go (both standard library available via third-party extensions), PHP and Ruby (legacy web sites and contrasting 
builtin vs library support), and Python (as a general purpose language). 

\begin{itemize}
    \item \textbf{Bash} was selected due to its foundational role in Unix-like operating systems and its extensive use in scripting and automation tasks that heavily interact with file 
    system style operations.
    \item \textbf{JavaScript/Node.js} was chosen for its ubiquity in modern web development, where glob patterns are frequently used for file management, build processes, and routing in 
    frameworks like \emph{Express.js}.
    \item \textbf{PHP and Ruby} were included to represent server-side web development environments where glob patterns are often utilized in file handling and asset management tasks. These 
    languages also provide a contrast between built-in globbing capabilities (Ruby) and third-party library implementations (PHP).
    \item \textbf{Go} was selected for its growing popularity in systems programming and cloud-native applications, where efficient file pattern matching is crucial. Go's standard library includes builtin 
    globbing functionality, and is complemented by several third-party libraries that extend its capabilities.
    \item \textbf{Python} was included due to its versatility and widespread adoption across various domains, including data science, web development, and automation. Globbing in Python 
    is also implemented in multiple, slightly different ways, including the built-in \texttt{glob} module and \texttt{pathlibPath.glob()}.
\end{itemize}

For each language, we analyzed the canonical (or popular $3^{\text{rd}}$ party) glob implementation: Python's \texttt{glob} and \texttt{pathlib.Path.glob()}, 
Node.js's \texttt{glob} package (200+ million weekly downloads), Ruby's \texttt{Dir.glob()}, Go's \texttt{filepath.Glob()} with third-party alternatives, PHP's \texttt{glob()} 
function, and Bash's native expansion. We conducted cross-platform testing on Linux, macOS, and Windows to evaluate semantic differences in case sensitivity, path separator handling, 
and hidden file behavior.

\subsection{Repository Selection and Pattern Extraction}

We constructed a representative corpus through stratified sampling of $1,966$ active GitHub repositories (Python: $377$, JavaScript: $365$, Shell: $331$, Go: $314$, PHP: $300$, Ruby: $279$) 
meeting these criteria \todo{there were some review comments here about inconsistencies and details -- please address}:

\begin{itemize}
\item Primary language composition $>50\%$ to ensure idiomatic usage
\item Minimum 150 GitHub stars indicating community adoption
\item Active maintenance (commits within preceding 12 months)
\item Exclusion of archived or deprecated repositories
\end{itemize}

We utilized a suite of per-language regular expressions, included in the reproduction package, for extracting and analyzing glob usage. Post extraction we manually reviewed a random 
sample of $150$ repositories to evaluate extraction accuracy. This validation showed a recall rate of $94\%$ and a precision rate of $99\%$.

\begin{figure}[htbp]
    \centering
    \includegraphics[width=\columnwidth]{language_prevalence.pdf}
    \caption{Distribution of glob pattern occurrence across programming languages. Fig. (a) shows the percentage of repositories containing at least one glob pattern. Fig. (b) 
    reports the total number of globs extracted from repositories in each language.}
    \label{fig:language_prevalence}
\end{figure}


\subsection{Glob Frequency and Distribution}

Our language selection strategy targeted six programming ecosystems representing diverse implementation approaches and application domains. 
\Cref{fig:language_prevalence} shows significant variation in both repository penetration (the percentage of repositories containing glob patterns) 
and total pattern volume across languages. Python demonstrates the highest adoption with a number of $18,806$ of all extracted patterns, reflecting 
its prevalence in file-system-intensive domains like data science and scripting. Go follows with $17,798$, while Node.js, PHP, Ruby, and Shell show 
more modest but strategically important usage patterns. This distribution informed our stratified sampling approach, ensuring adequate representation 
of both high-volume ecosystems and specialized use cases while maintaining statistical power for cross-language comparison.

\begin{figure}[htbp]
    \centering
    \includegraphics[width=\columnwidth]{source_comparison.pdf}
    \caption{Distribution of glob patterns by source file type, comparing configuration files (YAML, JSON, INI configs) versus language source code files across all studied languages. 
    Across all languages The vast majority of glob patterns are found in configuration files.}
    \label{fig:source_comparison}
\end{figure}

\Cref{fig:language_prevalence} (b) shows the final corpus comprises $62,713$ validated patterns with distribution: Python $(29.99\%)$, JavaScript $(14.67\%)$, 
Go $(28.38\%)$, PHP $(6.08\%)$, Ruby $(12.79\%)$, Shell $(8.09\%)$. \Cref{fig:source_comparison} shows configuration files $(91.0\%)$ 
dominate source code use $(9.0\%)$. This bias towards configuration contexts, along with the prevalent use of glob patterns in code to describe resources such as 
file paths or URL routes, is notable and suggests that glob patterns are primarily employed for declarative resource specification rather that for search/replacement 
style tasks that are seen with regular expressions.

% After extraction each pattern was automatically classified, based on syntax and language semantic analysis, into a taxonomy of $13$ features organized into three categories:

% \begin{enumerate}
% \item \textbf{Basic Functionality}: Wildcard (\texttt{*}), recursive wildcard (\texttt{**}), single-character (\texttt{?}), character classes (\texttt{[]})
% \item \textbf{Extended Patterns}: Brace expansion (\texttt{\{\}}), negation (\texttt{!}), extended glob operators, character ranges
% \item \textbf{Environmental Functionality}: Hidden files, absolute paths, directory qualifiers, escape characters, variable interpolation
% \end{enumerate}

% Feature detection employed context-sensitive regular expressions with disambiguation rules. For example, brace expansion detection used \verb|(?<!\$)\{([^}]+)\}| to exclude variable expansion. Validation on 500 randomly selected patterns achieved 100\% agreement with manual annotation.

\subsection{Qualitative Data Collection and Analysis}

Our qualitative data study utilizes 2,094 developer discussions from three complementary sources ranging in time from 2018-2024 to capture a broad spectrum of glob-related issues 
involving usability, reliability, security, and performance concerns:

\begin{itemize}
\item \textbf{Stack Overflow}: $361$ questions revealing help-seeking behavior and conceptual difficulties
\item \textbf{GitHub Issues}: $1,355$ reports documenting production problems and feature requests  
\item \textbf{CVE Database}: $444$ entries cataloging security vulnerabilities and exploits
\end{itemize}

We performed API scraping with keyword-based filtering -- (core: "glob", "wildcard"; feature-specific: "recursive glob", "brace expansion"; problem-specific: "glob error", "security")~\cite{labelprediction}
to collect relevant posts. Quality filters \todo{what filters??} excluded low-score posts and duplicates. The resulting corpus was manually reviewed to ensure topical relevance, yielding a final dataset of $2,160$ posts 
which are included in the reproduction artifact.

Using an iterative hybrid coding approach, combining deductive and inductive methods outlined below, we developed a taxonomy of glob-related developer issues. 

\begin{enumerate}
\item \textbf{Deductive initial categories}: Derived from software engineering literature: Usability, Reliability, Security, Performance, Feature Gaps, Compatibility
\item \textbf{Automated categorization}: Keyword-based scoring assigned posts to primary categories
\item \textbf{Inductive subcategory refinement}: Phrase frequency analysis identified recurring themes within each category
\item \textbf{Validation}: Analysis of "Other" categories confirmed taxonomy completeness despite natural heterogeneity in developer problem descriptions
\end{enumerate}

In addition to developer initiated discussion we also conducted an systematic review of the official documentation for all studied glob 
implementations~\cite{BashGlob,GoGlob,RubyGlob,PythonFnmatch,PythonGlob,PythonPathlib,PHPGlob,NodeGlob}. This analysis identified documentation gaps, platform-specific 
behavior omissions, and evolutionary changes across library versions. For instance, we tracked Python's Unicode handling improvements from version $2$ to 
$3$~\cite{python2-3}, Node.js's recursive matching enhancements, and Bash's extended glob support in version $4.0+$.
